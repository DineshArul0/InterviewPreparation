[
  { "id": "selenium-theory-easy-026", "type": "theory", "difficulty": "Easy", "question": "What is a window handle?", "answer": "A window handle is a unique identifier that WebDriver assigns to each browser window or tab. It's used to switch between different windows." },
  { "id": "selenium-theory-easy-027", "type": "theory", "difficulty": "Easy", "question": "How do you get all window handles?", "answer": "You use the `driver.getWindowHandles()` method, which returns a `Set` of strings containing all the unique window handles." },
  { "id": "selenium-theory-easy-028", "type": "theory", "difficulty": "Easy", "question": "How do you switch to a different window?", "answer": "You get all window handles using `driver.getWindowHandles()`, then iterate through them and use `driver.switchTo().window(handle)` to switch to the desired window." },
  { "id": "selenium-theory-easy-029", "type": "theory", "difficulty": "Easy", "question": "What is the purpose of taking a screenshot in test automation?", "answer": "To capture the state of the browser at a specific point, usually when a test fails. This provides visual evidence of the error and helps in debugging." },
  { "id": "selenium-theory-easy-030", "type": "theory", "difficulty": "Easy", "question": "What is the difference between `linkText` and `partialLinkText` locators?", "answer": "`linkText` matches the exact visible text of a link. `partialLinkText` matches a portion of the link's visible text." },
  { "id": "selenium-theory-easy-031", "type": "theory", "difficulty": "Easy", "question": "Which locator is generally considered the best to use?", "answer": "`id` is usually the best because it's unique and fast. If an `id` is not available, a well-written `cssSelector` is often the next best choice." },
  { "id": "selenium-theory-easy-032", "type": "theory", "difficulty": "Easy", "question": "What is a `WebElement`?", "answer": "A `WebElement` is an object that represents an HTML element on a web page. All interactions with the page, like clicking or typing, are performed on `WebElement` objects." },
  { "id": "selenium-theory-easy-033", "type": "theory", "difficulty": "Easy", "question": "How do you get the value of an element's attribute, like `href`?", "answer": "You locate the element and then use the `.getAttribute(\"attributeName\")` method. For example, `.getAttribute(\"href\")`." },
  { "id": "selenium-theory-easy-034", "type": "theory", "difficulty": "Easy", "question": "What is a test framework (like JUnit or TestNG)?", "answer": "A framework that provides a structure for writing and running tests. It offers features like assertions, test runners, annotations, and reporting to organize and manage test automation." },
  { "id": "selenium-theory-easy-035", "type": "theory", "difficulty": "Easy", "question": "What is an assertion in testing?", "answer": "An assertion is a statement that checks if a condition is true. If the condition is false, the test fails. It's used to verify that the application is behaving as expected." },
  { "id": "selenium-theory-easy-036", "type": "theory", "difficulty": "Easy", "question": "What is the `@Test` annotation in TestNG or JUnit?", "answer": "The `@Test` annotation marks a method as a test case, indicating that it should be run by the test framework." },
  { "id": "selenium-theory-easy-037", "type": "theory", "difficulty": "Easy", "question": "What are the `@BeforeMethod` and `@AfterMethod` annotations used for?", "answer": "`@BeforeMethod` marks a method that runs before each test method. It's often used for setup tasks. `@AfterMethod` marks a method that runs after each test method, often used for cleanup." },
  { "id": "selenium-theory-easy-038", "type": "theory", "difficulty": "Easy", "question": "What is the purpose of `Thread.sleep()` and why should it be avoided?", "answer": "`Thread.sleep()` pauses the test script for a fixed amount of time. It should be avoided because it makes tests slow and unreliable. It's better to use Selenium's dynamic waits." },
  { "id": "selenium-theory-easy-039", "type": "theory", "difficulty": "Easy", "question": "What is a wait in Selenium?", "answer": "A wait is a command that tells WebDriver to pause execution and wait for a certain condition to be met before continuing. This is essential for handling elements that don't load instantly." },
  { "id": "selenium-theory-easy-040", "type": "theory", "difficulty": "Easy", "question": "What is an implicit wait?", "answer": "An implicit wait tells WebDriver to poll the DOM for a certain amount of time when trying to find an element. Once set, it applies to the entire session." },
  { "id": "selenium-theory-easy-041", "type": "theory", "difficulty": "Easy", "question": "What is an explicit wait?", "answer": "An explicit wait is a piece of code that waits for a specific condition to occur before proceeding. It is applied to a specific element and is more flexible than an implicit wait." },
  { "id": "selenium-theory-easy-042", "type": "theory", "difficulty": "Easy", "question": "What is the `WebDriverWait` class?", "answer": "The `WebDriverWait` class is the primary class used for implementing explicit waits in Selenium. You use it with an `ExpectedConditions` class to define the condition to wait for." },
  { "id": "selenium-theory-easy-043", "type": "theory", "difficulty": "Easy", "question": "What is an `ExpectedCondition`?", "answer": "An `ExpectedCondition` is a condition that the `WebDriverWait` will wait for. The `ExpectedConditions` class provides many predefined conditions, like `elementToBeClickable` or `visibilityOfElementLocated`." },
  { "id": "selenium-theory-easy-044", "type": "theory", "difficulty": "Easy", "question": "How do you get the title of the current page?", "answer": "You use the `driver.getTitle()` method, which returns the title as a String." },
  { "id": "selenium-theory-easy-045", "type": "theory", "difficulty": "Easy", "question": "How do you get the URL of the current page?", "answer": "You use the `driver.getCurrentUrl()` method, which returns the URL as a String." },
  { "id": "selenium-theory-easy-046", "type": "theory", "difficulty": "Easy", "question": "What is the difference between `driver.get()` and `driver.navigate().to()`?", "answer": "They both do the same thing: navigate to a URL. `driver.get()` is just a more convenient shorthand for `driver.navigate().to()`." },
  { "id": "selenium-theory-easy-047", "type": "theory", "difficulty": "Easy", "question": "How do you clear the text from an input field?", "answer": "You locate the input element and then call the `.clear()` method on it." },
  { "id": "selenium-theory-easy-048", "type": "theory", "difficulty": "Easy", "question": "What is the `By` class in Selenium?", "answer": "The `By` class is a mechanism used to locate elements within a document. It provides static methods for each locator type, such as `By.id()`, `By.name()`, `By.cssSelector()`, etc." },
  { "id": "selenium-theory-easy-049", "type": "theory", "difficulty": "Easy", "question": "Can you interact with hidden elements?", "answer": "No, WebDriver is designed to interact with the web page like a real user, so it cannot directly click or type into elements that are not visible. Doing so will result in an `ElementNotInteractableException`." },
  { "id": "selenium-theory-easy-050", "type": "theory", "difficulty": "Easy", "question": "What is the purpose of the browser driver (e.g., `chromedriver.exe`)?", "answer": "The browser driver is a separate executable file that acts as a bridge between the Selenium WebDriver script and the actual browser. It translates the script's commands into instructions the browser can understand." }
]
